In Java, the `java.lang.Object` class is the root of the entire class hierarchy. It is the cosmic base classâ€”meaning every single class you create or use in Java implicitly inherits from `Object`.

Because of this, every object in Java automatically comes pre-packaged with a specific set of methods. Understanding these methods is crucial because they define the foundational behaviors of all Java objects.

Here is an in-depth explanation of the methods provided by the `Object` class, categorized by their primary purpose.

---

## 1. Data Representation and Comparison

These are the most commonly overridden methods. You will frequently rewrite these in your own classes to give your objects meaningful behavior.

### **`toString()`**

* **Purpose:** Returns a string representation of the object.
* **Default Behavior:** By default, it prints the class name followed by an `@` symbol and the object's hash code in hexadecimal (e.g., `Student@1b6d3586`).
* **Why Override:** You override this to return a human-readable string containing the object's actual data. If you print an object (`System.out.println(myObject)`), Java implicitly calls its `toString()` method.

### **`equals(Object obj)`**

* **Purpose:** Compares the current object with another object to check if they are "equal."
* **Default Behavior:** The default implementation uses the `==` operator, which only checks if the two object references point to the exact same memory location in the Heap.
* **Why Override:** You override this to define **logical equality**. For example, if you have two separate `User` objects in memory, but they both have the exact same `emailAddress`, you would override `equals()` to declare them as equal.

### **`hashCode()`**

* **Purpose:** Returns an integer value (a hash code) generated by a hashing algorithm based on the object's memory address or state.
* **Usage:** It is heavily used by hash-based collections like `HashMap`, `HashSet`, and `HashTable` to sort and locate objects quickly in memory.
* **The Golden Rule:** If you override the `equals()` method, you **must** also override the `hashCode()` method. If two objects are deemed equal by the `equals()` method, they must produce the exact same hash code.

---

## 2. Object Copying and Metadata

These methods are used to inspect the object's type at runtime or to duplicate the object.

### **`getClass()`**

* **Purpose:** Returns the runtime class object of this object.
* **Usage:** This is used heavily in Java **Reflection**. It allows you to inspect the exact metadata of an object while the program is running (e.g., finding out the object's class name, its methods, or its variables dynamically).
* **Note:** This method is marked `final`, meaning no class can ever override it. An object cannot lie about what class it belongs to.

### **`clone()`**

* **Purpose:** Creates and returns an exact copy (a shallow copy) of the object.
* **Usage:** To use this method, your class must implement the `Cloneable` interface. If you call `clone()` on an object that hasn't implemented this interface, it will throw a `CloneNotSupportedException`. It is declared as `protected`, meaning you usually need to override it as `public` to use it outside the class.

---

## 3. Thread Synchronization (Concurrency)

Java has built-in multithreading capabilities. The `Object` class provides methods to allow threads to communicate with each other when sharing a single object.

*These methods can only be called from within a `synchronized` block or method.*

| Method | Explanation |
| --- | --- |
| **`wait()`** | Tells the current thread to pause execution and release its lock on the object. The thread will wait dormant until another thread calls `notify()` or `notifyAll()` on the same object. |
| **`wait(long timeout)`** | Same as `wait()`, but the thread will automatically wake up after the specified number of milliseconds if no one notifies it. |
| **`notify()`** | Wakes up a **single** thread that is currently waiting on this object's monitor (lock). If multiple threads are waiting, the JVM arbitrarily picks one to wake up. |
| **`notifyAll()`** | Wakes up **all** threads that are currently waiting on this object. |

---

## 4. Garbage Collection (Lifecycle)

### **`finalize()`**

* **Purpose:** This method is called by the Garbage Collector right before the object is permanently deleted from Heap memory.
* **Usage:** Historically, developers used this to execute cleanup code (like closing file streams or network connections) just before the object died.
* **Note:** This method is **deprecated** as of Java 9. It is highly unpredictable because you never know exactly when (or if) the Garbage Collector will run. Modern Java uses `try-with-resources` blocks for cleanup instead.
