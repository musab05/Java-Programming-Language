Welcome back to our lecture series. After mastering how we store and manipulate data in memory with Collections, we now need to address a critical real-world requirement: **Persistence**.

In professional software development, data doesn't just live in RAM; it needs to be read from configuration files, saved to logs, or exported to reports. This brings us to **Java I/O (Input/Output)**.

Java's I/O system is built on a "Stream" metaphor—think of data flowing like water through a pipe. We have two main types of pipes:

1. **Byte Streams:** For binary data (images, videos).
2. **Character Streams:** For text data (what we are focusing on today).

---

## 1. The `File` Class: The Navigator

Before you can read or write, you need to point to a location. The `File` class doesn't actually read the content; it represents the **metadata** of the file or directory.

### Key Capabilities:

* Checking if a file exists: `file.exists()`
* Checking permissions: `file.canRead()`
* File management: `file.createNewFile()` or `file.delete()`
* Directory navigation: `file.isDirectory()`

**Senior Dev Tip:** In modern Java (7+), we often use the `java.nio.file.Path` and `Paths` classes, which are more powerful. However, understanding the `File` class is still essential for maintaining legacy enterprise systems.

---

## 2. Reading Data: `FileReader` and `BufferedReader`

To read text from a file, we use a "Chain of Responsibility" pattern.

### `FileReader`: The Specialist

This is a low-level character stream. It reads a file character by character.

* **The Issue:** Reading character-by-character is incredibly slow (it requires a system call for every single letter).

### `BufferedReader`: The Efficiency Expert

We wrap the `FileReader` inside a `BufferedReader`. It reads large chunks of the file into a "buffer" (a temporary memory area) all at once. When you ask for the next line, it gives it to you from RAM rather than the disk.

**The Implementation:**

```java
File file = new File("notes.txt");
try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}

```

---

## 3. Writing Data: `BufferedWriter`

Just like reading, writing data one character at a time is inefficient. `BufferedWriter` allows us to write strings and lines to an internal buffer. The data is only actually written to the disk (a "flush") when the buffer is full or the stream is closed.

### Why use `BufferedWriter`?

* **Performance:** Drastically reduces the number of I/O operations.
* **Convenience:** Provides the `newLine()` method, which automatically uses the correct line separator for the operating system (Windows vs. Linux).

**The Implementation:**

```java
try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
    writer.write("Hello, Java I/O!");
    writer.newLine();
    writer.write("This is an efficient way to write text.");
} catch (IOException e) {
    e.printStackTrace();
}

```

---

## 4. The "Try-With-Resources" Pattern

In the examples above, you’ll notice I used `try ( ... )`. This is a professional standard introduced in Java 7.

In the old days, we had to manually close files in a `finally` block. If we forgot, we caused a **Memory Leak** or a **File Lock** (preventing other programs from using the file). With "Try-With-Resources," Java automatically closes any object that implements the `AutoCloseable` interface.

---

## 5. Comparison: Streams vs. Writers

| Class | Type | Purpose |
| --- | --- | --- |
| **`FileReader`** | Connection Stream | Connects to a file to read characters. |
| **`BufferedReader`** | Chain Stream | Adds a buffer to make reading faster. |
| **`FileWriter`** | Connection Stream | Connects to a file to write characters. |
| **`BufferedWriter`** | Chain Stream | Adds a buffer to make writing faster. |

---

## Summary Checklist for your Code Reviews:

1. **Always use Buffering:** Never use `FileReader` or `FileWriter` alone for large files.
2. **Always close your streams:** Use Try-With-Resources.
3. **Handle exceptions:** I/O operations are "checked," meaning you *must* handle `IOException`.
4. **Use absolute paths carefully:** For production, prefer relative paths or classpath-based resource loading to ensure the app works on different servers.
