Now that we’ve mastered how to store and traverse data, we face a critical question in any enterprise application: **How do we sort it?**

If you have a list of numbers or strings, `Collections.sort()` works like magic. But what if you have a list of `Employee` objects? Does Java sort them by ID, Name, or Salary? It has no way of knowing—unless you tell it.

In Java, we use two primary interfaces to define sorting logic: **Comparable** and **Comparator**.

---

## 1. Comparable: "The Natural Order"

`Comparable` is used when a class has one **default** way of being sorted. For example, Strings are naturally sorted alphabetically; Integers are naturally sorted numerically.

When a class implements `Comparable`, it defines its own "Natural Ordering" by overriding the `compareTo()` method.

### Key Characteristics:

* **Package:** `java.lang` (it’s so fundamental it’s in the core language package).
* **Method:** `public int compareTo(T o)`
* **Intrusive:** You must modify the actual class source code to implement it.

### How it works:

* Returns a **negative integer** if `this` is smaller than `o`.
* Returns **zero** if `this` is equal to `o`.
* Returns a **positive integer** if `this` is greater than `o`.

**Example:**

```java
class Student implements Comparable<Student> {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Default sorting by ID
    @Override
    public int compareTo(Student other) {
        return this.id - other.id; 
    }
}

```

---

## 2. Comparator: "The Flexible Alternative"

What if you want to sort `Students` by `name` sometimes and by `id` other times? Or what if you are using a class from a library (like `String`) and you can't modify its source code?

That’s where `Comparator` comes in. It is a separate class (or lambda) that tells Java how to compare **two different** objects.

### Key Characteristics:

* **Package:** `java.util`
* **Method:** `public int compare(T o1, T o2)`
* **Non-intrusive:** You don't touch the original class; you create a separate "sorting strategy."

**Example (Modern Lambda Style):**

```java
// Sorting by Name using a Comparator
Comparator<Student> nameComparator = (s1, s2) -> s1.name.compareTo(s2.name);

Collections.sort(studentList, nameComparator);

```

---

## 3. Comparable vs. Comparator: Head-to-Head

| Feature | Comparable | Comparator |
| --- | --- | --- |
| **Purpose** | Defines the **default** (natural) sorting. | Defines **multiple** custom sorting rules. |
| **Implementation** | Class implements it (`this` vs `object`). | Separate class/lambda (`object1` vs `object2`). |
| **Modification** | Requires modifying the original class. | Original class remains untouched. |
| **Method** | `compareTo(obj)` | `compare(obj1, obj2)` |
| **Flexibility** | Rigid (Only one sort rule). | Highly flexible (Infinite rules). |

---

## 4. Practical Example: The Multi-Sort Dashboard

As a developer, you often provide a "Natural Sort" but allow users to toggle different views.

```java
import java.util.*;

public class SortingDemo {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(105, "Zayn"));
        students.add(new Student(101, "Alice"));
        students.add(new Student(103, "Charlie"));

        // 1. Natural Sort (by ID, defined in Student class)
        Collections.sort(students); 
        System.out.println("Sorted by ID: " + students);

        // 2. Custom Sort (by Name, defined on the fly)
        Collections.sort(students, (s1, s2) -> s1.name.compareTo(s2.name));
        System.out.println("Sorted by Name: " + students);
    }
}

```

---

## Senior Dev Tip: Chaining Comparators

In modern Java (8+), you can chain comparators to handle "tie-breakers." For example, if two employees have the same salary, you might want to sort them by name next.

```java
Comparator<Employee> multiComparator = Comparator
    .comparing(Employee::getSalary)
    .thenComparing(Employee::getName);

employees.sort(multiComparator);

```

This is much cleaner than the old-school nested `if-else` blocks we used to write!
